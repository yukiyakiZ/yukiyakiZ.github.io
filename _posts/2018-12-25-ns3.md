---
layout: post
title: "NS-3 Simulation Pipeline"
excerpt: ""
categories: [network]
comments: true
---

<p class="lead text-justify">
    Though NS-3 provides nice examples and descriptions,
    unfortunately, they were written in a zigzag pattern and appear less straightforward to me during the practice.
    It also takes time to sort out the mesh relationships among components and aggregate the
  scattered information to form a <font class="font-italic">linear logic pattern</font>.
    Hence, this tutorial is to depict a step-by-step pipeline to conduct an NS-3 simulation.
</p>

<h3>S0: Prerequisites</h3>
<ul class="lead text-justify">
  <li>
    <font class="font-italic">Why simulation?</font>
    It is necessary to pick the right methodology (simulation, emulation, testbed, real-world deployment)
    for the target networking problem.
  </li>
  <li>
    <font class="font-italic">Why NS-3?</font>
    There is a bunch of open-source simulators (NS-2, NS-3...).
    For me, I picked NS-3 since I like C++/Python programming and it is convenient to interface NS-3 with
    emulations and machine learning frameworks.
  </li>
  <li>
    <font class="font-italic">C++ coding style:</font>
    I found it helpful to follow the <a href="https://www.nsnam.org/develop/contributing-code/coding-style/#Name_encoding">NS-3 coding style</a>
    from the very beginning, e.g., Camel cases for classes and camelBack for variables.
  </li>
  <li>
    <font class="font-italic">Documentation:</font>
    The <a href="https://www.nsnam.org/docs/manual/html/index.html">NS-3 manual</a>,
    <a href="https://www.nsnam.org/docs/tutorial/html/">NS-3 tutorial</a> are must reads.
    Besides, the NS-3 source code is the <font class="font-italic">best</font> documentation for me and provides answers to specific questions
    not mentioned in the NS-3 wiki, doxygen.
    For example, when setting <code>OnOffApplication</code> data rate attribute, it is unclear from the NS-3 documentation
    if such rate is an averaged rate.
    One could easily peek into the source code and figure out from both the attribute system and the calculation
    of the next scheduling event that it refers to the rate during the on-state transmission:


{% highlight cpp %}
// A snapshot of {NS-3 tree prefix}/src/applications/model/onoff-application.cc
TypeId
OnOffApplication::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::OnOffApplication")
    .SetParent<Application> ()
    .SetGroupName("Applications")
    .AddConstructor<OnOffApplication> ()
    .AddAttribute ("DataRate", "The data rate in on state.",
                   DataRateValue (DataRate ("500kb/s")),
                   MakeDataRateAccessor (&OnOffApplication::m_cbrRate),
                   MakeDataRateChecker ())
    //...
}
void OnOffApplication::ScheduleNextTx ()
{
  NS_LOG_FUNCTION (this);

  if (m_maxBytes == 0 || m_totBytes < m_maxBytes)
    {
      uint32_t bits = m_pktSize * 8 - m_residualBits;
      NS_LOG_LOGIC ("bits = " << bits);
      Time nextTime (Seconds (bits /
                              static_cast<double>(m_cbrRate.GetBitRate ()))); // Time till next packet
      NS_LOG_LOGIC ("nextTime = " << nextTime);
      m_sendEvent = Simulator::Schedule (nextTime,
                                         &OnOffApplication::SendPacket, this);
    }
  else
    { // All done, cancel any pending events
      StopApplication ();
    }
}
{% endhighlight %}

<h3>S1: Crystallization of Simulation Details</h3>
<p class="lead text-justify">I summarized the following list of components whose details
  are worth consideration prior simulation.</p>
<ul class="lead text-justify">
  <li>
    <font class="font-italic">Nodes:</font> How many nodes will exist in the simulation?
    It is helpful to <font class="font-italic">classify</font> them a priori since typically nodes of the same category
    will be stored in the same <code>NodeContainer</code>.
  </li>
  <li>
    <font class="font-italic">Links:</font> Each link corresponds to a pair of <code>NetDevices</code> and
    the connecting <code>Channel</code>.
    One node could possess multiple NetDevices interfacing the network, as in real-world systems.
    Since both components are highly coupled (e.g., WifiNetDevice-WifiChannel, CsmaNetDevice-CsmaChannel),
    one will typically determine the features of the <code>NetDevices</code>
    and the <code>Channel</code> jointly.
    NS-3 reflects such an idea by introducing the <code>PointToPointHelper</code> and its subclasses.
    One needs to decide on the type of link depending on the network context.
  </li>
  <li>
    <font class="font-italic">Queues:</font>
    New versions of NS-3 introduce the <a href="https://www.nsnam.org/workshops/wns3-2016/wns3-traffic-control.pdf">traffic control layer</a>
    facing the IP interface.
    Hence, one needs to <a href="https://www.nsnam.org/docs/models/html/queue-discs.html">differentiate</a>
    between NetDeviceQueue (Linux struct netdev_queue equivalent) and QueueDisc (<a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/">Linux qdisc</a>
    equivalent) for simulation.
  </li>
  <li>
    <font class="font-italic">Applications:</font>
    Flows and packets are generated by Applications which are installed at the source nodes.
    One should clearly define the details of the workloads in the simulation, e.g., flow size distribution,
    packet size, intervals and so forth.
  </li>
  <li>
    <font class="font-italic">Protocols:</font>
    Each pair of communicating node will agree on a specific protocol.
    It is necessary to detail the protocol(s) for each communicating sessions.
  </li>
  <li>
    <font class="font-italic">Addressing:</font>
    One needs to make sure that the addressing mechanism assigned to each nodes will not collide.
  </li>
  <li>
    <font class="font-italic">Routing:</font>
    Typically, one just apply NS-3 built-in helpers such as <code>Ipv4GlobalRoutingHelper</code>.
  </li>
  <li>
    <font class="font-italic">Metrics:</font>
    The whole point of the simulation is to evaluate the network performances, measured by the corresponding metrics.
    It is crucial to decide on the metrics of the network performances before the simulation.
  </li>
</ul>
<h3>S2: Implementation and Analysis</h3>
<ul class="lead text-justify">
  <li>
    <font class="font-italic">Launcher program location:</font>
    For a simple simulation program, one could simply place it at path <code>{NS-3 tree prefix}/scratch/{name}.cc</code>.
    For complicated ones, one could set up a folder and provides a .cc file inside with point of entry function (main).
    <code>waf</code> system (similar to GNU Make) will automatically compile/link the program.
    One could, e.g., modify <code>{NS-3 tree prefix}/wscript</code> to change the behaviors of the build system.
  </li>
  <li>
    <font class="font-italic">Network translation:</font>
    The implementation is about translating the target network in the form of NS-3 models.
    In general, it is about create nodes =>
    configure attributes of the add-ons (NetDevices, channel, Stacks, Applications, Addresses ...) =>
    install add-ons on the nodes =>
    configure tracing => trigger simulation engine.
  </li>
  <li>
    <font class="font-italic">Out-of-tree extension:</font>
    What if the standard modules are not sufficient to build the simulation?
    One could add functions/attributes to existing NS-3 classes or
    <a href="https://www.nsnam.org/docs/manual/html/new-modules.html">build a new module</a>.
  </li>
  <li>
    <font class="font-italic">Execution automation:</font>
    One might need to run a series of experiments with different <a href="https://www.nsnam.org/docs/manual/html/random-variables.html">random seeds</a>
    (for controllable  reproduction), hyper-parameters.
    One could introduce NS-3 <a href="https://www.nsnam.org/docs/tutorial/html/tweaking.html#using-command-line-arguments">command line arguments</a>
    and write a shell script to automate the tests.
  </li>
  <li>
    <font class="font-italic">Result analysis:</font>
    <a href="https://pdfs.semanticscholar.org/2ecc/d9cf497abe709ae2e1b4c7b8aa6e3d5e22f2.pdf">Flow Monitor module</a>
    could be used to aggregate flow-level statistics.
    <a href="https://www.nsnam.org/docs/manual/html/tracing.html">Tracing system</a> could enable flexible tracing sinks to collect simulation outputs.
    One could further derive custom metrics,
    e.g., p99 FCT for short flows, average FCT for large flows,
    with statistical post-processing.
    One might also visualize the animation of the simulation with NetAnim.
  </li>
</ul>